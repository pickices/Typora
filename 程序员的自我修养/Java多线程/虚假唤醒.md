# 虚假唤醒

> 当一个条件满足时，很多线程都被唤醒了，但是只有其中部分是有用的唤醒，其它的唤醒都是无用功 
>
> 比如说买货，如果商品本来没有货物，突然进了一件商品，这是所有的线程都被唤醒了 ，但是只能一个人买，所以其他人都是假唤醒，获取不到对象的锁



线程调用wait()方法后，需要其他线程调用notify或者notifyAll方法后，线程才会从wait方法中返回， 而虚假唤醒(spurious wakeup)是指线程通过其他方式，从wait方法中返回。

下面是一个买票退票的操作例子：

余票：0

线程A：退票

线程B：买票

线程C：买票

线程B买票，发现没有余票，调用wait方法，线程进入等待队列中。

线程A进行退票操作，余票数量加一，然后调用notify 方法通知等待线程，此时线程B被唤醒执行购票操作。

***

假设此时同时有线程B，C买票：

线程B调用wait方法进入等待队列

线程C同样调用wait方法进入等待队列

线程A退票时，余票数量+1，线程A调用notify方法后，线程B马上竞争获取到锁，购票成功后余票为0

线程C此时刚醒来，正在wait竞争获取锁，当线程B释放锁，线程C获取锁后，会执行购买的操作，而此时是没有余票的。



## 怎么产生虚假唤醒

> 把 while (product >=1) {} 
>
> 换成 if (product >=1) {} 就会出现虚假唤醒

