# synchronized（同步锁）

**synchronized锁的是需要修改的对象，而不是方法！**

> 由于同一进程的多个线程共享同一块存储空间（堆和方法区），在带来方便的同时，也带来了访问冲突问题。
> 
> 为了保证数据在方法中被访问时的正确性，在访问时加入同步锁synchronized。
> 
> 当一个线程获得对象的排它锁，则独占资源，其他线程必须等待使用后释放锁即可。
> 
> 但同样存在以下问题：

- 一个线程持有锁会导致其他所有需要此锁的线程挂起
- 在多线程竞争下加锁，释放锁的时候会导致比较多的上下文切换和调度延时，引起性能问题
- 如果一个优先级高的线程等待—个优先级低的线程释放锁会导致优先级倒置，引起性能问题



synchronized有如下用法：

1. 修饰代码块：synchronized(xxx)｛｝，如果xxx不是静态的，锁的是xxx这个对象；如果xxx是静态的，则锁的是xxx的类对象
2. 修饰实例方法 public synchronized void run()，锁的是this这个对象
3. 修饰静态方法 public static synchronized void run();，锁的是this.getclass() 
4. 修饰类 synchronized(xxx.class)｛｝，锁的是xxx.class()

**本质上，synchronized修饰静态方法就是锁了该对象的类对象**



## Synchronized修饰非静态方法，实际上是对调用该方法的对象加锁，俗称“对象锁”。

> 情况1：同一个对象在两个线程中分别访问该对象的两个同步方法
> 
> 结果：会产生互斥。
> 
> 解释：因为锁针对的是对象，当对象调用一个synchronized方法时，其他同步方法需要等待其执行结束并释放锁后才能执行。

***

> 情况2：不同对象在两个线程中调用同一个同步方法
> 
> 结果：不会产生互斥。
> 
> 解释：因为是两个对象，锁针对的是对象，并不是方法，所以可以并发执行，不会互斥。形象的来说就是因为我们每个线程在调用方法的时候都是new一个对象，那么就会出现两个空间，两把钥匙。

## Synchronized修饰静态方法，实际上是对该类对象加锁，俗称“类锁”。

> 情况1：用类直接在两个线程中调用两个不同的同步方法
> 
> 结果：会产生互斥。
> 
> 解释：因为对静态对象加锁实际上对类（.class）加锁，类对象**永远**只有一个。

***

> 情况2：用一个类的静态对象在两个线程中调用静态方法或非静态方法
> 
> 结果：会产生互斥。
> 
> 解释：因为是一个对象调用，同上。

****

> 情况3：一个对象在两个线程中分别调用一个静态同步方法和一个非静态同步方法
> 
> 结果：不会产生互斥。
> 
> 解释：因为虽然是一个对象调用，但是两个方法的锁类型不同，调用的静态方法实际上是类对象在调用，非静态方法是在this对象里调用。即这两个方法产生的并不是同一个对象锁，因此不会互斥，会并发执行。



## 总结：

1. 对象锁钥匙只能有一把才能互斥，才能保证共享变量的唯一性
2. 在静态方法上的锁，和实例方法上的锁，默认不是同样的，如果同步需要制定两把锁一样。
3. .关于同一个类的方法上的锁，来自于调用该方法的对象，如果调用该方法的对象是相同的，那么锁必然相同，否则就不相同。比如new A().x() 和 new A().x(),对象不同，锁不同，如果A的单例的，就能互斥。
4. .静态方法加锁，能和所有其他静态方法加锁的进行互斥
5. 静态方法加锁，和xx.class锁效果一样，直接属于类的
